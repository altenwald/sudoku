defmodule SudokuConsole do
  alias SudokuGame.Board

  @highlight_cell IO.ANSI.green_background()

  def start do
    module = to_string(__MODULE__)

    with {:ok, board_pid} <- SudokuGame.start(module) do
      start(board_pid)
    end
  end

  def start(board_list) when is_list(board_list) do
    board = Board.new(board_list)
    module = to_string(__MODULE__)

    with {:ok, board_pid} <- SudokuGame.start(module, board) do
      start(board_pid)
    end
  end

  def start(board_pid) when is_pid(board_pid) do
    :ok = :persistent_term.put({__MODULE__, :chosen, board_pid}, nil)
    banner(board_pid)
    render(board_pid)
  end

  def continue do
    module = to_string(__MODULE__)

    with {:error, {:already_started, pid}} <- SudokuGame.start(module) do
      continue(pid)
    end
  end

  def continue(board_pid) when is_pid(board_pid) do
    banner(board_pid)
    render(board_pid)
  end

  def stop do
    SudokuGame.stop(__MODULE__)
  end

  def stop(board_pid) when is_pid(board_pid) do
    SudokuGame.stop(board_pid)
  end

  defp render(pid) do
    if n = :persistent_term.get({__MODULE__, :chosen, pid}, nil) do
      board(pid, n)
      stats(pid)
    else
      board(pid)
      stats(pid)
    end
  end

  def chosen(n) when n in 1..9 do
    module = to_string(__MODULE__)

    with {:error, {:already_started, pid}} <- SudokuGame.start(module) do
      chosen(pid, n)
    end
  end

  def chosen(board_pid, n) when is_pid(board_pid) and n in 1..9 do
    :persistent_term.put({__MODULE__, :chosen, board_pid}, n)
    render(board_pid)
  end

  def write(x, y, n \\ nil, pid \\ nil)

  def write(x, y, n, nil) do
    module = to_string(__MODULE__)

    if pid = SudokuGame.get_pid(module) do
      write(x, y, n, pid)
    else
      {:error, :game_not_found}
    end
  end

  def write(x, y, nil, pid) when x in 1..9 and y in 1..9 do
    if n = :persistent_term.get({__MODULE__, :chosen, pid}, nil) do
      case SudokuGame.play(pid, x, y, n) do
        {:ok, :continue} ->
          banner(pid)
          render(pid)

        {:error, errors} ->
          banner(pid)
          show_errors(errors)
          SudokuGame.undo(pid)
          render(pid)

        {:ok, :complete} ->
          game_over(pid)
      end
    end
  end

  def write(x, y, n, pid) when n in 1..9 do
    :persistent_term.put({__MODULE__, :chosen, pid}, n)
    write(x, y, nil, pid)
  end

  defp game_over(pid) do
    board(pid)
    stats(pid)
    SudokuGame.stop(pid)
    IO.puts("G A M E    O V E R")
    :ok
  end

  defp show_errors([]), do: :ok

  defp show_errors([{{x1, y1}, {x2, y2}, value} | rest]) do
    IO.puts("ERROR: (#{x1},#{y1}) collides with (#{x2},#{y2}) (value=#{value})")
    show_errors(rest)
  end

  defp show_errors({:no_solution, {x, y}, value}) do
    IO.puts("ERROR: wrong number #{value} in position (#{x},#{y})")
  end

  defp banner(pid) do
    """
    Altenwald Sudoku (#{inspect(pid)})
    """
  end

  defp board(pid) do
    SudokuGame.get_board(pid)
    |> to_string(nil, & &1)
    |> IO.puts()
  end

  defp board(pid, n) do
    SudokuGame.get_board(pid)
    |> to_string(n, &"#{@highlight_cell}#{&1}#{IO.ANSI.reset()}")
    |> IO.puts()
  end

  defp stats(pid) do
    stats = SudokuGame.get_stats(pid)

    IO.puts(
      "------------------------------------------------------------------------\n" <>
        "missing: 1=#{stats.missing[1]} 2=#{stats.missing[2]} 3=#{stats.missing[3]} " <>
        "4=#{stats.missing[4]} 5=#{stats.missing[5]} 6=#{stats.missing[6]} " <>
        "7=#{stats.missing[7]} 8=#{stats.missing[8]} 9=#{stats.missing[9]} " <>
        "     empty: #{stats.empty}\n" <>
        "time: #{stats.secs_played} seconds\n" <>
        "------------------------------------------------------------------------\n"
    )
  end

  @spec to_string(Board.t() | [[0..9]], Board.content(), (1..9 -> String.t())) :: String.t()
  @doc """
  Show the board from SudokuGame.Board. We can pass or the board
  struct data or the list generated by `Enum.to_list/1`.
  """
  def to_string(%_{cells: cells}, highlight_num, highlight_fun) do
    draw(fn xo, yo, x, y ->
      case cells[x + xo][y + yo] do
        nil -> "   "
        ^highlight_num -> " #{highlight_fun.(highlight_num)} "
        num -> " #{num} "
      end
    end)
  end

  def to_string(board, highlight_num, highlight_fun) when is_list(board) do
    draw(fn xo, yo, x, y ->
      board
      |> Enum.at(y + yo - 1, [])
      |> Enum.at(x + xo - 1, 0)
      |> case do
        nil -> "   "
        ^highlight_num -> highlight_fun.(" #{highlight_num} ")
        n -> " #{n} "
      end
    end)
  end

  defp draw(get_cell) do
    for yo <- [0, 3, 6] do
      for y <- 1..3 do
        for xo <- [0, 3, 6] do
          for x <- 1..3 do
            get_cell.(xo, yo, x, y)
          end
          |> Enum.join("|")
        end
        |> Enum.join("||")
        |> String.replace_prefix("", "||")
        |> String.replace_suffix("", "||\n")
        |> String.replace_suffix("", "++---+---+---++---+---+---++---+---+---++\n")
      end
      |> Enum.join("")
      |> String.replace_prefix("", "++---+---+---++---+---+---++---+---+---++\n")
    end
    |> Enum.join()
  end

  defimpl String.Chars, for: SudokuGame.Board do
    @moduledoc """
    Facility to show into the shell, using `IO.puts/1` (mainly), the board.
    """

    @spec to_string(SudokuGame.Board.t()) :: String.t()
    @doc """
    Show the board from SudokuGame.Board.
    """
    def to_string(board) do
      SudokuConsole.to_string(board, nil, & &1)
    end
  end
end
